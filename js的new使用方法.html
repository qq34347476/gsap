<!--http://www.jb51.net/article/24759.htm-->
<!--http://www.108js.com/article/article1/10201.html?id=1092-->

<!--<script type="text/javascript">
	function cat() {
		this.name = 'tom',
			this.height = '140',
			this.color = 'red',
			this.say = function() {
				console.log('my name is ' + this.name);
			}
		cat.prototype.eye = 'blue'

	}

	var animal = new cat()

	console.log(animal);
	animal.say()
</script>-->

<!--<script type="text/javascript">
	function a() {
		function Animal(name){
			this.n = name
		}
		console.log(Animal);//输出函数Animal
		var obj = {};//建立obj对象
		console.log(obj.__proto__);//输出原型链
		console.log(Animal.prototype);//输出Animal的原型对象prototype
		obj.__proto__ = Animal.prototype;//把obj的__proto__ 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：obj->Animal.prototype->Object.prototype->null
			
		var result = Animal.call(obj, "cat");//在obj对象的执行空间调用Animal函数并传递参数“cat”。即用Animal对象(js中万物皆对象)替换空对象obj,并传递参数'cat'给Animal再this.n = name创建对象的内容
		return typeof result === 'obj' ? result : obj;//如果返回的内容为对象则返回对象，否则返回空对象obj
	}
	console.log(a());
</script>-->

<!--<script type="text/javascript">
	function a() {
		function b() {
			this.n = '666'
		}
		var obj = {}
		var result = b.call(obj)
		return typeof result === 'obj' ? result : obj
	}

	console.log(a());
</script>-->

<!--<script type="text/javascript">
	function add(a,b){
		return a+b;
	}
	function cut(a,b){
		return a-b;
	}
	var result = add.call(cut,1,3)//将add函数的数据转为cut的数据，以为add和cut都是函数，所以从结果上分析，似乎是add函数替换了cut，add.call(sub,3,1) == add(3,1)。注意：先传数据后改变数据形式
	console.log(result);
</script>-->

<!--<script type="text/javascript">
	function b(value) {
		this.b = value
	}

	function x() {
		var a = {}//[]

		a.__proto__ = b.prototype//删除此行，a变为普通对象

		b.call(a, 2)//实际上就是把b函数变为a的数据类型然后传给a
		return a
	}
	console.log(x())//new b(2)
</script>-->
<!--<script type="text/javascript">
	var a = {a:100}
	function b(){
		this.b = '100'
	}
	var n = new b()//n为函数转换为对象后的特殊对象
	console.log(n);
</script>-->
<!--<script type="text/javascript">
	function b(value) {
		this.b = value
	}

	function x() {
		var a = {}//[],{a:1}

//		a.__proto__ = b.prototype//删除此行，a变为普通对象

		b.call(a, 2)//b必须是函数,a可以是数组或者对象，且如果不为空则将函数b转换后的结果追加到a对象末尾
		return a
	}
	console.log(x())//new b(2)
</script>-->
<!--<script type="text/javascript">
	var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
	Array.prototype.get = function(a, b) {
		var myBest = this.slice(a,b);
		return myBest
	}

	console.log(fruits.get(1,3));
</script>-->
<!--<html>

	<head>
		<title></title>
	</head>

	<body>
		<div class="container">
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
		</div>
		<script src="js/jquery-1.11.0.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">
			var elements = $('.container *')
			console.log(elements)//jq选择器返回
//			var element = Array.prototype.slice.call(elements)
			var arr = []
			for (var i = 0; i< elements.length;i++) {
				arr.push(elements[i])
			}
//			console.log(arr);//遍历获得数组,每个值代表一个选择器，指向子元素
//			
//			for (var n = 0;n<arr.length;n++) {
//				console.log(arr[n]);//再遍历获得html原型
//			}



		</script>
	</body>

</html>-->

<!--<html>

	<head>
		<title></title>
	</head>

	<body>
		<div class="container">
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
		</div>
		<script src="js/jquery-1.11.0.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">
			var elements = document.querySelectorAll('.box')

//			var element = Array.prototype.slice.call(elements)
			var arr = []
			for (var i = 0; i< elements.length;i++) {
				arr.push(elements[i])
			}
			

		</script>
	</body>

</html>-->

<!--<script type="text/javascript">
//	function test1(){
//		console.log("1");
//		(function(){//匿名函数自动执行
//			console.log('2');
//		})();
//	}
//	function test1(){
//		console.log("1");
//		(function(a){//获得参数
//			console.log(a);
//		})('666');
//	}
	function test1(){
		console.log("1");
		void (function(a){//+,-,~,void
			console.log(a);
		})('666');
	}
	test1()
</script>-->

<!--<script type="text/javascript">
//		Array.prototype.add = function(a,b){//函数对象
//			return a + b
//		}
//		Array.prototype.Fun= new Function();
//		Array.prototype.obj = {a:1}//普通对象
//		console.log(new Array());

	//	var temp1 = new Function();//原型对象
	//	Function.prototype = temp1;//赋值给函数的prototype
	//	console.log(Function)

	var person = function(name) {
		this.name = name
	};
	person.prototype.getName = function() {
		return this.name;
	}
	var zjh = new person('tom');
	console.log(zjh.__proto__);
	console.log(person.prototype);
	console.log(person.prototype.__proto__);
	console.log(Object.prototype);
	console.log(Object.prototype.__proto__)
</script>-->

<!--<script type="text/javascript">
	function a(){
		this.n = 'cat'
	}
	console.log(a.prototype);
</script>-->

<!--<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
	</body>
	<script type="text/javascript">
		function Animal(name) {
			this.name = name;
		}
		
		Animal.color = "black";
		Animal.prototype.say = function() {
			console.log("I'm " + this.name);
		};
		var cat = new Animal("cat");

		console.log(
			cat.name, //cat
			cat.height //undefined
		);
		cat.say(); //I'm cat

		console.log(
			Animal.name, //Animal
			Animal.color //back
		);
		console.log(cat);
//		Animal.say(); //Animal.say is not a function
	</script>

</html>-->

<!--<script type="text/javascript">
	function Animal(name) {
		this.name = name;
	}
	Animal.color = "black";
	Animal.prototype.say = function() {
		console.log("I'm " + this.name);
	};
	var cat = new Animal("cat");

	console.log(
		cat.name, //cat
		cat.height //undefined
	);
	cat.say(); //I'm cat

	console.log(
		Animal.name, //Animal
		Animal.color //back
	);
	//var obj = {};
	//obj.__proto__ = Animal.prototype;
	//var result = Animal.call(obj,"cat");
	//return typeof result === 'obj'? result : obj;
	var obj = {}
	
	console.log(obj.__proto__);
	console.log(Animal.prototype);
	obj.__proto__ = Animal.prototype
	console.log(obj.__proto__);
	console.log(obj.__proto__.say)
	var x = new Animal()
	console.log(x.__proto__);
	Animal.call(obj,"cat");//obj.Animal('cat')
	console.log(obj);
	console.log(new Animal('cat'));
	console.log(Animal.prototype);

	
//	console.log(result);
</script>-->

<!--<script type="text/javascript">
	function Person(){
		this.name = 'tom'
	}
	var x = new Person()
	console.log("x(x.__proto__) -> Person(Person.prototype)(Person.prototype.__proto__) -> Object(Object.prototype)(Object.prototype.__proto__) -> null");
	console.log("x:");
	console.log(x);
	console.log("x->");
	console.log(x.__proto__);
	console.log("Person");
	console.log(Person.prototype);
	console.log("Person->");
	console.log(Person.prototype.__proto__);
	console.log("Object");
	console.log(Object.prototype);
	console.log("Object->");
	console.log(Object.prototype.__proto__);
	
</script>-->

<!--<script type="text/javascript">
	function f() {
		this.a = "a";
		this.b = function() {
			alert("b");
		}
	}

	function e() {
		f.call(this);
	}
	var c = new e();
	alert(c.a); //弹出a
	c.b(); //弹出b
</script>-->

<!--<script type="text/javascript">
	var Class = {
			create: function() {
				return function() {
					this.initialize.apply(this, arguments);//A中的initialize函数将此函数替换掉，arguments即initialize的参数v,this.value = 'helloWord'
				}
			}
		}
		// Class使用方法如下 
	var A = Class.create();
	//A就是function() {
	//					this.initialize.apply(this, arguments);
	//				}
	A.prototype = {//在A的实例对象中添加两个函数
		initialize: function(v) {
			this.value = v;
		},
		showValue: function() {
			alert(this.value);
		}
	}
	var a = new A('helloWord!');
	console.log(a);
	a.showValue(); //弹出对话框helloWord！
</script>-->

<!--<script type="text/javascript">
	//	var sum = function(x, y) {
	//		return x + y
	//	};
	//
	//	var succ = sum.bind(null, 1); //让this指向null，其后的实参也会作为实参传入被绑定的函数sum
	//
	//	console.log(succ(2)); // => 3: 可以看到1绑定到了sum函数中的x

	//function func(a,b,c,d){}  //func的length为4
	//
	//var after = func.bind(null,1,2);  //这里输入了两个实参（1，2）绑定到了func函数的a，b
	//
	//console.log(after.length);  //after的length为2

	function original(x) {
		this.a = 1;
		this.b = function() {
			return this.a + x
		}
	}
	var obj = {
		a : 10
	}
	var newObj = new(original.bind(obj, 2)); //传入了一个实参2

	console.log(newObj.a); //输出1, 说明返回的函数用作构造函数时obj(this的值)被忽略了
	console.log(newObj.b()); //输出3 ，说明传入的实参2传入了原函数original
</script>-->

